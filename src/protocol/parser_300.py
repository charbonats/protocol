"""protocol.parser module."""

from __future__ import annotations

from typing import Iterator

from .common import (
    CRLF,
    CRLF_SIZE,
    Character,
    ErrorEvent,
    Event,
    MsgEvent,
    Operation,
    ProtocolError,
    State,
    make_history,
    parse_info,
)


class Parser:
    """NATS Protocol parser."""

    def __init__(self, debug_max_history: int = 0) -> None:
        # Initialize the parser state.
        self._closed = False
        self._state_history = make_history(debug_max_history)
        self._data_received = b""
        self._events_received: list[Event] = []
        # Initialize pending args
        self._partial_ascii_text = ""
        # Initialize pending message
        self._expected_header_size = 0
        self._expected_total_size = 0
        self._partial_msg: MsgEvent | None = None
        # Initialize the parser iterator
        self.__loop__ = self.__parse__()

    def history(self) -> list[State]:
        """Return the history of states."""
        if __debug__:
            return list(self._state_history)
        raise RuntimeError("history is only available in debug mode")

    def state(self) -> State:
        """Return the current state of the parser."""
        return self._state_history[-1]

    def events(self) -> list[Event]:
        """Pop and return the events generated by the parser."""
        events = self._events_received
        self._events_received = []
        return events

    def parse(self, data: bytes) -> None:
        self._data_received += data
        next(self.__loop__)

    def __parse__(self) -> Iterator[None]:
        """Parse some bytes."""

        if __debug__:
            assert self._state_history, "history is empty"
            assert (
                self._state_history[-1] == State.OP_START
            ), "history is not in the start state"

            def set_state(state: State) -> None:
                self._state_history.append(state)
        else:

            def set_state(state: State) -> None:
                self._state_history[-1] = state

        while True:
            # Exit when the parser is closed.
            if self._closed:
                return
            # If there is no data to parse, yield None.
            if not self._data_received:
                yield None
                continue
            # Take the first byte
            next_byte = self._data_received[0]
            # Take the remaining data
            pending_data = self._data_received = self._data_received[1:]
            # Get the current state
            state = self._state_history[-1]

            if state == State.OP_START:
                # MSG
                if next_byte == Character.M or next_byte == Character.m:
                    set_state(State.OP_M)
                    continue
                # HMSG
                elif next_byte == Character.H or next_byte == Character.h:
                    set_state(State.OP_H)
                    continue
                # PING/PONG
                elif next_byte == Character.P or next_byte == Character.p:
                    set_state(State.OP_P)
                    continue
                # INFO
                elif next_byte == Character.I or next_byte == Character.i:
                    set_state(State.OP_I)
                    continue
                # +OK
                elif next_byte == Character.plus:
                    set_state(State.OP_PLUS)
                    continue
                # -ERR
                elif next_byte == Character.minus:
                    set_state(State.OP_MINUS)
                    continue
                # Anything else is an error
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_H:
                if next_byte == Character.m or next_byte == Character.M:
                    set_state(State.OP_HM)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_HM:
                if next_byte == Character.s or next_byte == Character.S:
                    set_state(State.OP_HMS)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_HMS:
                if next_byte == Character.g or next_byte == Character.G:
                    set_state(State.OP_HMSG)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_HMSG:
                if next_byte == Character.space:
                    set_state(State.OP_HMSG_SPC)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_HMSG_SPC:
                if next_byte == Character.carriage_return:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.space:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._partial_ascii_text += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    set_state(State.HMSG_ARG)
                    continue

            elif state == State.HMSG_ARG:
                if next_byte == Character.carriage_return:
                    args = self._partial_ascii_text.split(" ")
                    self._partial_ascii_text = ""
                    nbargs = len(args)
                    if nbargs == 5:
                        (
                            subject,
                            raw_sid,
                            reply_to,
                            raw_header_size,
                            raw_total_size,
                        ) = args
                    elif nbargs == 4:
                        reply_to = ""
                        subject, raw_sid, raw_header_size, raw_total_size = args
                    else:
                        raise ProtocolError(next_byte, pending_data)
                    try:
                        self._expected_header_size = int(raw_header_size)
                        self._expected_total_size = int(raw_total_size)
                        sid = int(raw_sid)
                    except Exception as e:
                        raise ProtocolError(next_byte, pending_data) from e
                    self._partial_msg = MsgEvent(
                        Operation.HMSG,
                        sid=sid,
                        subject=subject,
                        reply_to=reply_to,
                        payload=b"",
                        header=b"",
                    )
                    set_state(State.HMSG_END)
                    continue
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._partial_ascii_text += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    continue

            elif state == State.HMSG_END:
                if next_byte == Character.newline:
                    set_state(State.HMSG_PAYLOAD)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.HMSG_PAYLOAD:
                assert self._partial_msg is not None, "pending_msg is None"
                pending_data = bytes([next_byte]) + pending_data
                if len(pending_data) >= self._expected_total_size + CRLF_SIZE:
                    msg = self._partial_msg
                    self._partial_msg = None

                    header = pending_data[: self._expected_header_size]
                    if header[-4:] != b"\r\n\r\n":
                        raise ProtocolError(next_byte, pending_data)
                    msg.header = header[:-4]

                    payload = pending_data[
                        self._expected_header_size : self._expected_total_size
                    ]
                    msg.payload = payload
                    self._data_received = pending_data[
                        self._expected_total_size + CRLF_SIZE :
                    ]
                    self._events_received.append(msg)
                    set_state(State.OP_END)
                    set_state(State.OP_START)
                    continue
                else:
                    self._data_received = pending_data
                    yield None
                    continue

            elif state == State.OP_M:
                if next_byte == Character.s or next_byte == Character.S:
                    set_state(State.OP_MS)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MS:
                if next_byte == Character.g or next_byte == Character.G:
                    set_state(State.OP_MSG)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MSG:
                if next_byte == Character.space:
                    set_state(State.OP_MSG_SPC)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MSG_SPC:
                if next_byte == Character.carriage_return:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.space:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._partial_ascii_text += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    set_state(State.MSG_ARG)
                    continue

            elif state == State.MSG_ARG:
                if next_byte == Character.carriage_return:
                    set_state(State.MSG_END)
                    args = self._partial_ascii_text.split(" ")
                    nbargs = len(args)
                    self._partial_ascii_text = ""
                    if nbargs == 4:
                        subject, raw_sid, reply_to, raw_total_size = args
                    elif nbargs == 3:
                        reply_to = ""
                        subject, raw_sid, raw_total_size = args
                    else:
                        raise ProtocolError(next_byte, pending_data)
                    try:
                        sid = int(raw_sid)
                        self._expected_total_size = int(raw_total_size)
                    except Exception as e:
                        raise ProtocolError(next_byte, pending_data) from e
                    self._partial_msg = MsgEvent(
                        Operation.MSG,
                        sid=sid,
                        subject=subject,
                        reply_to=reply_to,
                        payload=b"",
                        header=b"",
                    )
                    continue
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._partial_ascii_text += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    continue

            elif state == State.MSG_END:
                if next_byte == Character.newline:
                    set_state(State.MSG_PAYLOAD)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.MSG_PAYLOAD:
                assert self._partial_msg is not None, "pending_msg is None"
                pending_data = bytes([next_byte]) + pending_data
                if len(pending_data) >= self._expected_total_size + CRLF_SIZE:
                    msg = self._partial_msg
                    self._partial_msg = None
                    msg.payload = pending_data[: self._expected_total_size]
                    self._data_received = pending_data[
                        self._expected_total_size + CRLF_SIZE :
                    ]
                    self._events_received.append(msg)
                    set_state(State.OP_END)
                    set_state(State.OP_START)
                    continue
                else:
                    self._data_received = pending_data
                    yield None
                    continue

            elif state == State.OP_I:
                if next_byte == Character.n or next_byte == Character.N:
                    set_state(State.OP_IN)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_IN:
                if next_byte == Character.f or next_byte == Character.F:
                    set_state(State.OP_INF)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_INF:
                if next_byte == Character.o or next_byte == Character.O:
                    set_state(State.OP_INFO)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_INFO:
                if next_byte == Character.space:
                    set_state(State.OP_INFO_SPC)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_INFO_SPC:
                if next_byte == Character.left_json_bracket:
                    set_state(State.INFO_ARG)
                    pending = bytes([next_byte]) + pending_data
                    self._data_received = pending
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.INFO_ARG:
                pending = bytes([next_byte]) + pending_data
                if CRLF in pending:
                    end = pending.index(CRLF)
                    data = pending[:end]
                    self._data_received = pending[end + CRLF_SIZE :]
                    set_state(State.OP_END)
                    set_state(State.OP_START)
                    self._events_received.append(parse_info(data))
                    continue
                else:
                    self._data_received = pending
                    yield None
                    continue

            elif state == State.OP_PLUS:
                if next_byte == Character.o or next_byte == Character.O:
                    set_state(State.OP_PLUS_O)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PLUS_O:
                if next_byte == Character.k or next_byte == Character.K:
                    set_state(State.OP_PLUS_OK)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PLUS_OK:
                if next_byte == Character.carriage_return:
                    set_state(State.OP_END)
                    self._events_received.append(Event(Operation.OK))
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS:
                if next_byte == Character.e or next_byte == Character.E:
                    set_state(State.OP_MINUS_E)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS_E:
                if next_byte == Character.r or next_byte == Character.R:
                    set_state(State.OP_MINUS_ER)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS_ER:
                if next_byte == Character.r or next_byte == Character.R:
                    set_state(State.OP_MINUS_ERR)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS_ERR:
                if next_byte == Character.space:
                    set_state(State.OP_MINUS_ERR_SPC)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS_ERR_SPC:
                if next_byte == Character.carriage_return:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._partial_ascii_text += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    set_state(State.MINUS_ERR_ARG)
                    continue

            elif state == State.MINUS_ERR_ARG:
                if next_byte == Character.carriage_return:
                    msg = self._partial_ascii_text
                    set_state(State.OP_END)
                    self._events_received.append(ErrorEvent(Operation.ERR, msg))
                    self._partial_ascii_text = ""
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._partial_ascii_text += chr(next_byte)
                        continue
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_P:
                if next_byte == Character.i or next_byte == Character.I:
                    set_state(State.OP_PI)
                    continue
                elif next_byte == Character.o or next_byte == Character.O:
                    set_state(State.OP_PO)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PI:
                if next_byte == Character.n or next_byte == Character.N:
                    set_state(State.OP_PIN)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PIN:
                if next_byte == Character.g or next_byte == Character.G:
                    set_state(State.OP_PING)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PING:
                if next_byte == Character.carriage_return:
                    set_state(State.OP_END)
                    self._events_received.append(Event(Operation.PING))
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PO:
                if next_byte == Character.n or next_byte == Character.N:
                    set_state(State.OP_PON)
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PON:
                if next_byte == Character.g or next_byte == Character.G:
                    set_state(State.OP_PONG)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PONG:
                if next_byte == Character.carriage_return:
                    set_state(State.OP_END)
                    self._events_received.append(Event(Operation.PONG))
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_END:
                if next_byte == Character.newline:
                    set_state(State.OP_START)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            else:
                raise ProtocolError(next_byte, pending_data)
