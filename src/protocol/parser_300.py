"""
NATS protocol parser.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Iterator

from .common import (
    CRLF,
    CRLF_SIZE,
    ErrorEvent,
    Event,
    MsgEvent,
    Operation,
    ProtocolError,
    State,
    parse_info,
    plus,
    minus,
    o,
    O,
    k,
    K,
    e,
    E,
    r,
    R,
    p,
    P,
    s,
    S,
    h,
    H,
    m,
    M,
    g,
    G,
    i,
    I,
    n,
    N,
    f,
    F,
    space,
    new_line,
    carriage_return,
    left_json_bracket,
)


STOP_HEADER = bytearray(b"\r\n\r\n")


class Parser300:
    """NATS Protocol parser."""

    def __init__(self) -> None:
        # Initialize the parser state.
        self._closed = False
        self._state = State.OP_START
        self._data_received = bytearray()
        self._events_received: list[Event] = []
        # Initialize the parser iterator
        self.__loop__ = self.__parse__()

    def events_received(self) -> list[Event]:
        """Pop and return the events generated by the parser."""
        events = self._events_received
        self._events_received = []
        return events

    def parse(self, data: bytes | bytearray) -> None:
        self._data_received += data
        next(self.__loop__)

    def __parse__(self) -> Iterator[None]:
        """Parse some bytes."""

        cursor = 0
        expected_header_size = 0
        expected_total_size = 0
        partial_msg: MsgEvent | None = None

        while True:
            # Exit when the parser is closed.
            if self._closed:
                return
            # If there is no data to parse, yield None.
            if not self._data_received:
                yield None
                continue
            # Take the first byte
            next_byte = self._data_received[cursor]
            # Get the current state
            state = self._state

            if state == State.OP_START:
                # MSG
                if next_byte == M or next_byte == m:
                    self._state = State.OP_M
                    cursor += 1
                    continue
                # HMSG
                elif next_byte == H or next_byte == h:
                    self._state = State.OP_H
                    cursor += 1
                    continue
                # PING/PONG
                elif next_byte == P or next_byte == p:
                    self._state = State.OP_P
                    cursor += 1
                    continue
                # INFO
                elif next_byte == I or next_byte == i:
                    self._state = State.OP_I
                    cursor += 1
                    continue
                # +OK
                elif next_byte == plus:
                    self._state = State.OP_PLUS
                    cursor += 1
                    continue
                # -ERR
                elif next_byte == minus:
                    self._state = State.OP_MINUS
                    cursor += 1
                    continue
                # Anything else is an error
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_H:
                if next_byte == m or next_byte == M:
                    self._state = State.OP_HM
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_HM:
                if next_byte == s or next_byte == S:
                    self._state = State.OP_HMS
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_HMS:
                if next_byte == g or next_byte == G:
                    self._state = State.OP_HMSG
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_HMSG:
                if next_byte == space:
                    self._state = State.OP_HMSG_SPC
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_HMSG_SPC:
                if next_byte == carriage_return:
                    raise ProtocolError(next_byte, self._data_received)
                elif next_byte == new_line:
                    raise ProtocolError(next_byte, self._data_received)
                elif next_byte == space:
                    raise ProtocolError(next_byte, self._data_received)
                else:
                    self._state = State.HMSG_ARG
                    self._data_received = self._data_received[cursor:]
                    cursor = 1
                    continue

            elif state == State.HMSG_ARG:
                if CRLF in self._data_received:
                    end = self._data_received.find(CRLF)
                    args = self._data_received[:end].decode().split(" ")
                    nbargs = len(args)
                    if nbargs == 5:
                        (
                            subject,
                            raw_sid,
                            reply_to,
                            raw_header_size,
                            raw_total_size,
                        ) = args
                    elif nbargs == 4:
                        reply_to = ""
                        subject, raw_sid, raw_header_size, raw_total_size = args
                    else:
                        raise ProtocolError(next_byte, self._data_received)
                    try:
                        expected_header_size = int(raw_header_size)
                        expected_total_size = int(raw_total_size)
                        sid = int(raw_sid)
                    except Exception as exc:
                        raise ProtocolError(next_byte, self._data_received) from exc
                    partial_msg = MsgEvent(
                        Operation.HMSG,
                        sid=sid,
                        subject=subject,
                        reply_to=reply_to,
                        payload=bytearray(),
                        header=bytearray(),
                    )
                    self._state = State.HMSG_END
                    cursor = end + 1
                    continue
                else:
                    yield None
                    continue

            elif state == State.HMSG_END:
                if next_byte == new_line:
                    self._state = State.HMSG_PAYLOAD
                    self._data_received = self._data_received[cursor + 1 :]
                    cursor = 0
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.HMSG_PAYLOAD:
                assert partial_msg is not None, "pending_msg is None"
                if len(self._data_received) >= expected_total_size + CRLF_SIZE:
                    msg = partial_msg
                    partial_msg = None

                    header = self._data_received[:expected_header_size]
                    if header[-4:] != STOP_HEADER:
                        raise ProtocolError(next_byte, self._data_received)
                    msg.header = header[:-4]

                    payload = self._data_received[
                        expected_header_size:expected_total_size
                    ]
                    msg.payload = payload
                    self._data_received = self._data_received[
                        expected_total_size + CRLF_SIZE + 1 :
                    ]
                    self._events_received.append(msg)
                    self._state = State.OP_END
                    self._state = State.OP_START
                    cursor = 0
                    continue
                else:
                    yield None
                    continue

            elif state == State.OP_M:
                if next_byte == s or next_byte == S:
                    self._state = State.OP_MS
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_MS:
                if next_byte == g or next_byte == G:
                    self._state = State.OP_MSG
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_MSG:
                if next_byte == space:
                    self._state = State.OP_MSG_SPC
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_MSG_SPC:
                if next_byte == carriage_return:
                    raise ProtocolError(next_byte, self._data_received)
                elif next_byte == new_line:
                    raise ProtocolError(next_byte, self._data_received)
                elif next_byte == space:
                    raise ProtocolError(next_byte, self._data_received)
                else:
                    self._state = State.MSG_ARG
                    self._data_received = self._data_received[cursor:]
                    cursor = 1
                    continue

            elif state == State.MSG_ARG:
                if CRLF in self._data_received:
                    end = self._data_received.find(CRLF)
                    args = self._data_received[:end].decode().split(" ")
                    nbargs = len(args)
                    if nbargs == 4:
                        subject, raw_sid, reply_to, raw_total_size = args
                    elif nbargs == 3:
                        reply_to = ""
                        subject, raw_sid, raw_total_size = args
                    else:
                        raise ProtocolError(next_byte, self._data_received)
                    try:
                        sid = int(raw_sid)
                        expected_total_size = int(raw_total_size)
                    except Exception as exc:
                        raise ProtocolError(next_byte, self._data_received) from exc
                    partial_msg = MsgEvent(
                        Operation.MSG,
                        sid=sid,
                        subject=subject,
                        reply_to=reply_to,
                        payload=bytearray(),
                        header=bytearray(),
                    )
                    cursor = end + 1
                    self._state = State.MSG_END
                    continue
                else:
                    yield None
                    continue

            elif state == State.MSG_END:
                if next_byte == new_line:
                    self._state = State.MSG_PAYLOAD
                    self._data_received = self._data_received[cursor + 1 :]
                    cursor = 0
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.MSG_PAYLOAD:
                assert partial_msg is not None, "pending_msg is None"
                if len(self._data_received) >= expected_total_size + CRLF_SIZE:
                    msg = partial_msg
                    partial_msg = None
                    msg.payload = self._data_received[:expected_total_size]
                    self._data_received = self._data_received[
                        expected_total_size + CRLF_SIZE + 1 :
                    ]
                    self._events_received.append(msg)
                    self._state = State.OP_END
                    self._state = State.OP_START
                    cursor = 0
                    continue
                else:
                    yield None
                    continue

            elif state == State.OP_I:
                if next_byte == n or next_byte == N:
                    self._state = State.OP_IN
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_IN:
                if next_byte == f or next_byte == F:
                    self._state = State.OP_INF
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_INF:
                if next_byte == o or next_byte == O:
                    self._state = State.OP_INFO
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_INFO:
                if next_byte == space:
                    self._state = State.OP_INFO_SPC
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_INFO_SPC:
                if next_byte == left_json_bracket:
                    self._state = State.INFO_ARG
                    self._data_received = self._data_received[cursor:]
                    cursor = 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.INFO_ARG:
                if CRLF in self._data_received:
                    end = self._data_received.index(CRLF)
                    data = self._data_received[:end]
                    self._state = State.OP_END
                    self._state = State.OP_START
                    self._data_received = self._data_received[end + CRLF_SIZE + 1 :]
                    cursor = 0
                    self._events_received.append(parse_info(data))
                    continue
                else:
                    yield None
                    continue

            elif state == State.OP_PLUS:
                if next_byte == o or next_byte == O:
                    self._state = State.OP_PLUS_O
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_PLUS_O:
                if next_byte == k or next_byte == K:
                    self._state = State.OP_PLUS_OK
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_PLUS_OK:
                if next_byte == carriage_return:
                    self._state = State.OP_END
                    self._data_received = self._data_received[cursor + 1 :]
                    cursor = 0
                    self._events_received.append(Event(Operation.OK))
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_MINUS:
                if next_byte == e or next_byte == E:
                    self._state = State.OP_MINUS_E
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_MINUS_E:
                if next_byte == r or next_byte == R:
                    self._state = State.OP_MINUS_ER
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_MINUS_ER:
                if next_byte == r or next_byte == R:
                    self._state = State.OP_MINUS_ERR
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_MINUS_ERR:
                if next_byte == space:
                    self._state = State.OP_MINUS_ERR_SPC
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_MINUS_ERR_SPC:
                if next_byte == carriage_return:
                    raise ProtocolError(next_byte, self._data_received)
                elif next_byte == new_line:
                    raise ProtocolError(next_byte, self._data_received)
                else:
                    self._data_received = self._data_received[cursor:]
                    cursor = 1
                    self._state = State.MINUS_ERR_ARG
                    continue

            elif state == State.MINUS_ERR_ARG:
                if CRLF in self._data_received:
                    end = self._data_received.find(CRLF)
                    msg = self._data_received[:end].decode()
                    self._state = State.OP_END
                    self._events_received.append(ErrorEvent(Operation.ERR, msg))
                    self._data_received = self._data_received[end + 1 :]
                    cursor = 0
                else:
                    yield None
                    continue
            elif state == State.OP_P:
                if next_byte == i or next_byte == I:
                    self._state = State.OP_PI
                    cursor += 1
                    continue
                elif next_byte == o or next_byte == O:
                    self._state = State.OP_PO
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_PI:
                if next_byte == n or next_byte == N:
                    self._state = State.OP_PIN
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_PIN:
                if next_byte == g or next_byte == G:
                    self._state = State.OP_PING
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_PING:
                if next_byte == carriage_return:
                    self._state = State.OP_END
                    self._data_received = self._data_received[cursor + 1 :]
                    cursor = 0
                    self._events_received.append(Event(Operation.PING))
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_PO:
                if next_byte == n or next_byte == N:
                    self._state = State.OP_PON
                    cursor += 1
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_PON:
                if next_byte == g or next_byte == G:
                    self._state = State.OP_PONG
                    cursor += 1
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_PONG:
                if next_byte == carriage_return:
                    self._state = State.OP_END
                    self._data_received = self._data_received[cursor + 1 :]
                    cursor = 0
                    self._events_received.append(Event(Operation.PONG))
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            elif state == State.OP_END:
                if next_byte == new_line:
                    self._state = State.OP_START
                    self._data_received = self._data_received[cursor + 1 :]
                    cursor = 0
                    continue
                else:
                    raise ProtocolError(next_byte, self._data_received)

            else:
                raise ProtocolError(next_byte, self._data_received)


if TYPE_CHECKING:
    from .common import Parser as ParserProtocol

    # Verify that Parser implements ParserProtocol
    parser: ParserProtocol = Parser300()
