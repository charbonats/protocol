"""protocol.parser module."""

from collections import deque
from dataclasses import dataclass
from enum import IntEnum, auto
from typing import Iterator

CRLF_SIZE = len(b"\r\n")


class ProtocolError(Exception):
    """Protocol error."""

    def __init__(self, invalid_byte: int, bad_value: bytes) -> None:
        self.bad_value = bad_value
        self.invalid_byte = invalid_byte
        super().__init__(f"unexpected byte: {bytes([invalid_byte])}")


class State(IntEnum):
    OP_START = 0
    OP_PLUS = auto()
    OP_PLUS_O = auto()
    OP_PLUS_OK = auto()
    OP_MINUS = auto()
    OP_MINUS_E = auto()
    OP_MINUS_ER = auto()
    OP_MINUS_ERR = auto()
    OP_MINUS_ERR_SPC = auto()
    MINUS_ERR_ARG = auto()
    OP_M = auto()
    OP_MS = auto()
    OP_MSG = auto()
    OP_MSG_SPC = auto()
    MSG_ARG = auto()
    MSG_PAYLOAD = auto()
    MSG_END = auto()
    OP_H = auto()
    OP_HM = auto()
    OP_HMS = auto()
    OP_HMSG = auto()
    OP_HMSG_SPC = auto()
    HMSG_ARG = auto()
    HMSG_END = auto()
    HMSG_PAYLOAD = auto()
    OP_P = auto()
    OP_PI = auto()
    OP_PIN = auto()
    OP_PING = auto()
    OP_PO = auto()
    OP_PON = auto()
    OP_PONG = auto()
    OP_I = auto()
    OP_IN = auto()
    OP_INF = auto()
    OP_INFO = auto()
    OP_INFO_SPC = auto()
    INFO_ARG = auto()
    OP_END = auto()


class Character(IntEnum):
    # +/-
    plus = ord("+")
    minus = ord("-")
    # ok
    o = ord("o")
    O = ord("O")
    k = ord("k")
    K = ord("K")
    # err
    e = ord("e")
    E = ord("E")
    r = ord("r")
    R = ord("R")
    # pub
    p = ord("p")
    P = ord("P")
    u = ord("u")
    U = ord("U")
    b = ord("b")
    B = ord("B")
    # sub
    s = ord("s")
    S = ord("S")
    # hpub
    h = ord("h")
    H = ord("H")
    # msg
    m = ord("m")
    M = ord("M")
    g = ord("g")
    G = ord("G")
    # ping
    i = ord("i")
    I = ord("I")
    n = ord("n")
    N = ord("N")
    # info
    f = ord("f")
    F = ord("F")
    # special characters
    space = ord(" ")
    newline = ord("\n")
    carriage_return = ord("\r")


class Operation(IntEnum):
    OK = 0
    ERR = auto()
    MSG = auto()
    HMSG = auto()
    INFO = auto()
    PING = auto()
    PONG = auto()


@dataclass
class Event:
    """NATS Protocol event."""

    operation: Operation


@dataclass
class ErrorEvent(Event):
    """NATS Protocol error event."""

    message: str


@dataclass
class MsgEvent(Event):
    """NATS Protocol message event."""

    sid: int
    subject: str
    reply_to: str
    payload: bytes
    header: bytes


class Parser:
    """NATS Protocol parser."""

    def __init__(self, history: int = 0) -> None:
        if history < -1:
            raise ValueError(
                "history must be -1, 0 or a positive integer. "
                "-1 means unlimited history. "
                "0 means no history. "
                "A positive integer means the maximum number of states to keep in history excluding the current state."
            )
        # Initialize the parser history.
        self._history: deque[State] = deque(
            maxlen=history + 1 if history >= 0 else None
        )
        self._events: list[Event] = []
        self._error_message = ""
        # Raw fields
        self._header_size = 0
        self._total_size = 0
        self._pending_msg: MsgEvent | None = None
        self._pending_args = ""
        # Initialize the parser state.
        self._history.append(State.OP_START)
        self._data = b""
        self._closed = False
        self.__loop__ = self.__parse__()

    def history(self) -> list[State]:
        """Return the history of states."""
        if __debug__:
            return list(self._history)
        raise RuntimeError("history is only available in debug mode")

    def state(self) -> State:
        """Return the current state of the parser."""
        return self._history[-1]

    def events(self) -> list[Event]:
        """Pop and return the events generated by the parser."""
        events = self._events
        self._events = []
        return events

    def parse(self, data: bytes) -> None:
        self._data += data
        next(self.__loop__)

    def __parse__(self) -> Iterator[None]:
        """Parse some bytes."""

        if __debug__:
            if not self._history:
                raise AssertionError("history is empty")
            if self._history[-1] != State.OP_START:
                raise AssertionError("history is not in the start state")

            def set_state(state: State) -> None:
                self._history.append(state)
        else:

            def set_state(state: State) -> None:
                self._history[-1] = state

        # Infinite loop until the parser is closed.
        while not self._closed:
            # If there is no data to parse, yield None.
            if not self._data:
                yield None
                continue
            # Take the first byte
            next_byte = self._data[0]
            # Take the remaining data
            pending_data = self._data = self._data[1:]
            # Get the current state
            state = self._history[-1]
            # Parse the byte according to the current state
            if state == State.OP_START:
                if next_byte == Character.m or next_byte == Character.M:
                    self._expect_headers = False
                    set_state(State.OP_M)
                    continue
                elif next_byte == Character.h or next_byte == Character.H:
                    self._expect_headers = True
                    set_state(State.OP_H)
                    continue
                elif next_byte == Character.p or next_byte == Character.P:
                    set_state(State.OP_P)
                    continue
                elif next_byte == Character.plus:
                    set_state(State.OP_PLUS)
                    continue
                elif next_byte == Character.minus:
                    set_state(State.OP_MINUS)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_H:
                if next_byte == Character.m or next_byte == Character.M:
                    set_state(State.OP_HM)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_HM:
                if next_byte == Character.s or next_byte == Character.S:
                    set_state(State.OP_HMS)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_HMS:
                if next_byte == Character.g or next_byte == Character.G:
                    set_state(State.OP_HMSG)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_HMSG:
                if next_byte == Character.space:
                    set_state(State.OP_HMSG_SPC)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_HMSG_SPC:
                if next_byte == Character.carriage_return:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.space:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._pending_args += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    set_state(State.HMSG_ARG)
                    continue

            elif state == State.HMSG_ARG:
                if next_byte == Character.carriage_return:
                    args = self._pending_args.split(" ")
                    self._pending_args = ""
                    nbargs = len(args)
                    if nbargs == 5:
                        (
                            subject,
                            raw_sid,
                            reply_to,
                            raw_header_size,
                            raw_total_size,
                        ) = args
                    elif nbargs == 4:
                        reply_to = ""
                        subject, raw_sid, raw_header_size, raw_total_size = args
                    else:
                        raise ProtocolError(next_byte, pending_data)
                    try:
                        self._header_size = int(raw_header_size)
                        self._total_size = int(raw_total_size)
                        sid = int(raw_sid)
                    except Exception as e:
                        raise ProtocolError(next_byte, pending_data) from e
                    self._pending_msg = MsgEvent(
                        Operation.HMSG,
                        sid=sid,
                        subject=subject,
                        reply_to=reply_to,
                        payload=b"",
                        header=b"",
                    )
                    set_state(State.HMSG_END)
                    continue
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._pending_args += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    continue

            elif state == State.HMSG_END:
                if next_byte == Character.newline:
                    set_state(State.HMSG_PAYLOAD)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.HMSG_PAYLOAD:
                assert self._pending_msg is not None, "pending_msg is None"
                pending_data = bytes([next_byte]) + pending_data
                if len(pending_data) >= self._total_size + CRLF_SIZE:
                    msg = self._pending_msg
                    self._pending_msg = None

                    header = pending_data[: self._header_size]
                    if header[-4:] != b"\r\n\r\n":
                        raise ProtocolError(next_byte, pending_data)
                    msg.header = header[:-4]

                    payload = pending_data[self._header_size : self._total_size]
                    msg.payload = payload
                    self._data = pending_data[self._total_size + CRLF_SIZE :]
                    self._events.append(msg)
                    set_state(State.OP_END)
                    set_state(State.OP_START)
                    continue
                else:
                    self._data = pending_data
                    yield None
                    continue

            elif state == State.OP_M:
                if next_byte == Character.s or next_byte == Character.S:
                    set_state(State.OP_MS)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MS:
                if next_byte == Character.g or next_byte == Character.G:
                    set_state(State.OP_MSG)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MSG:
                if next_byte == Character.space:
                    set_state(State.OP_MSG_SPC)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MSG_SPC:
                if next_byte == Character.carriage_return:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.space:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._pending_args += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    set_state(State.MSG_ARG)
                    continue

            elif state == State.MSG_ARG:
                if next_byte == Character.carriage_return:
                    set_state(State.MSG_END)
                    args = self._pending_args.split(" ")
                    nbargs = len(args)
                    self._pending_args = ""
                    if nbargs == 4:
                        subject, raw_sid, reply_to, raw_total_size = args
                    elif nbargs == 3:
                        reply_to = ""
                        subject, raw_sid, raw_total_size = args
                    else:
                        raise ProtocolError(next_byte, pending_data)
                    try:
                        sid = int(raw_sid)
                        self._total_size = int(raw_total_size)
                    except Exception as e:
                        raise ProtocolError(next_byte, pending_data) from e
                    self._pending_msg = MsgEvent(
                        Operation.MSG,
                        sid=sid,
                        subject=subject,
                        reply_to=reply_to,
                        payload=b"",
                        header=b"",
                    )
                    continue
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._pending_args += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    continue

            elif state == State.MSG_END:
                if next_byte == Character.newline:
                    set_state(State.MSG_PAYLOAD)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.MSG_PAYLOAD:
                assert self._pending_msg is not None, "pending_msg is None"
                pending_data = bytes([next_byte]) + pending_data
                if len(pending_data) >= self._total_size + CRLF_SIZE:
                    msg = self._pending_msg
                    self._pending_msg = None
                    msg.payload = pending_data[: self._total_size]
                    self._data = pending_data[self._total_size + CRLF_SIZE :]
                    self._events.append(msg)
                    set_state(State.OP_END)
                    set_state(State.OP_START)
                    continue
                else:
                    self._data = pending_data
                    yield None
                    continue

            elif state == State.OP_PLUS:
                if next_byte == Character.o or next_byte == Character.O:
                    set_state(State.OP_PLUS_O)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PLUS_O:
                if next_byte == Character.k or next_byte == Character.K:
                    set_state(State.OP_PLUS_OK)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PLUS_OK:
                if next_byte == Character.carriage_return:
                    set_state(State.OP_END)
                    self._events.append(Event(Operation.OK))
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS:
                if next_byte == Character.e or next_byte == Character.E:
                    set_state(State.OP_MINUS_E)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS_E:
                if next_byte == Character.r or next_byte == Character.R:
                    set_state(State.OP_MINUS_ER)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS_ER:
                if next_byte == Character.r or next_byte == Character.R:
                    set_state(State.OP_MINUS_ERR)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS_ERR:
                if next_byte == Character.space:
                    set_state(State.OP_MINUS_ERR_SPC)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_MINUS_ERR_SPC:
                if next_byte == Character.carriage_return:
                    raise ProtocolError(next_byte, pending_data)
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._error_message += chr(next_byte)
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)
                    set_state(State.MINUS_ERR_ARG)
                    continue

            elif state == State.MINUS_ERR_ARG:
                if next_byte == Character.carriage_return:
                    msg = self._error_message
                    set_state(State.OP_END)
                    self._events.append(ErrorEvent(Operation.ERR, msg))
                    self._error_message = ""
                elif next_byte == Character.newline:
                    raise ProtocolError(next_byte, pending_data)
                else:
                    try:
                        self._error_message += chr(next_byte)
                        continue
                    except Exception:
                        raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_P:
                if next_byte == Character.i or next_byte == Character.I:
                    set_state(State.OP_PI)
                    continue
                elif next_byte == Character.o or next_byte == Character.O:
                    set_state(State.OP_PO)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PI:
                if next_byte == Character.n or next_byte == Character.N:
                    set_state(State.OP_PIN)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PIN:
                if next_byte == Character.g or next_byte == Character.G:
                    set_state(State.OP_PING)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PING:
                if next_byte == Character.carriage_return:
                    set_state(State.OP_END)
                    self._events.append(Event(Operation.PING))
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PO:
                if next_byte == Character.n or next_byte == Character.N:
                    set_state(State.OP_PON)
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PON:
                if next_byte == Character.g or next_byte == Character.G:
                    set_state(State.OP_PONG)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_PONG:
                if next_byte == Character.carriage_return:
                    set_state(State.OP_END)
                    self._events.append(Event(Operation.PONG))
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            elif state == State.OP_END:
                if next_byte == Character.newline:
                    set_state(State.OP_START)
                    continue
                else:
                    raise ProtocolError(next_byte, pending_data)

            else:
                raise ProtocolError(next_byte, pending_data)
