"""protocol.parser module."""

from __future__ import annotations

from typing import Iterator

from .common import (
    CRLF,
    CRLF_SIZE,
    Character,
    ErrorEvent,
    Event,
    MsgEvent,
    Operation,
    ProtocolError,
    State,
    make_history,
    parse_info,
)


class Parser:
    """NATS Protocol parser."""

    def __init__(self, debug_max_history: int = 0) -> None:
        # Initialize the parser state.
        self._closed = False
        self._state_history = make_history(debug_max_history)
        self._data_received = b""
        self._events_received: list[Event] = []
        # Initialize pending args
        self._partial_ascii_text = ""
        # Initialize pending message
        self._expected_header_size = 0
        self._expected_total_size = 0
        self._partial_msg: MsgEvent | None = None
        # Initialize the parser iterator
        self.__loop__ = self.__parse__()

    def history(self) -> list[State]:
        """Return the history of states."""
        if __debug__:
            return list(self._state_history)
        raise RuntimeError("history is only available in debug mode")

    def state(self) -> State:
        """Return the current state of the parser."""
        return self._state_history[-1]

    def events(self) -> list[Event]:
        """Pop and return the events generated by the parser."""
        events = self._events_received
        self._events_received = []
        return events

    def parse(self, data: bytes) -> None:
        self._data_received += data
        next(self.__loop__)

    def __parse__(self) -> Iterator[None]:
        """Parse some bytes."""

        if __debug__:
            assert self._state_history, "history is empty"
            assert (
                self._state_history[-1] == State.OP_START
            ), "history is not in the start state"

            def set_state(state: State) -> None:
                self._state_history.append(state)
        else:

            def set_state(state: State) -> None:
                self._state_history[-1] = state

        while True:
            # Exit when the parser is closed.
            if self._closed:
                return
            # If there is no data to parse, yield None.
            if not self._data_received:
                yield None
                continue
            # Take the first byte
            next_byte = self._data_received[0]
            # Take the remaining data
            pending_data = self._data_received = self._data_received[1:]
            # Get the current state
            state = self._state_history[-1]

            match state:
                case State.OP_START:
                    match next_byte:
                        case Character.M | Character.m:
                            set_state(State.OP_M)
                            continue
                        case Character.H | Character.h:
                            set_state(State.OP_H)
                            continue
                        case Character.P | Character.p:
                            set_state(State.OP_P)
                            continue
                        case Character.I | Character.i:
                            set_state(State.OP_I)
                            continue
                        case Character.plus:
                            set_state(State.OP_PLUS)
                            continue
                        case Character.minus:
                            set_state(State.OP_MINUS)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_H:
                    match next_byte:
                        case Character.M | Character.m:
                            set_state(State.OP_HM)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_HM:
                    match next_byte:
                        case Character.S | Character.s:
                            set_state(State.OP_HMS)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_HMS:
                    match next_byte:
                        case Character.G | Character.g:
                            set_state(State.OP_HMSG)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_HMSG:
                    match next_byte:
                        case Character.space:
                            set_state(State.OP_HMSG_SPC)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_HMSG_SPC:
                    match next_byte:
                        case Character.carriage_return:
                            raise ProtocolError(next_byte, pending_data)
                        case Character.newline:
                            raise ProtocolError(next_byte, pending_data)
                        case Character.space:
                            raise ProtocolError(next_byte, pending_data)
                        case _:
                            try:
                                self._partial_ascii_text += chr(next_byte)
                            except Exception:
                                raise ProtocolError(next_byte, pending_data)
                            set_state(State.HMSG_ARG)
                            continue
                case State.HMSG_ARG:
                    match next_byte:
                        case Character.newline:
                            raise ProtocolError(next_byte, pending_data)
                        case Character.carriage_return:
                            args = self._partial_ascii_text.split(" ")
                            self._partial_ascii_text = ""
                            match len(args):
                                case 5:
                                    (
                                        subject,
                                        raw_sid,
                                        reply_to,
                                        raw_header_size,
                                        raw_total_size,
                                    ) = args
                                case 4:
                                    reply_to = ""
                                    (
                                        subject,
                                        raw_sid,
                                        raw_header_size,
                                        raw_total_size,
                                    ) = args
                                case _:
                                    raise ProtocolError(next_byte, pending_data)
                            try:
                                self._expected_header_size = int(raw_header_size)
                                self._expected_total_size = int(raw_total_size)
                                sid = int(raw_sid)
                            except Exception as e:
                                raise ProtocolError(next_byte, pending_data) from e
                            self._partial_msg = MsgEvent(
                                Operation.HMSG,
                                sid=sid,
                                subject=subject,
                                reply_to=reply_to,
                                payload=b"",
                                header=b"",
                            )
                            set_state(State.HMSG_END)
                            continue
                        case _:
                            try:
                                self._partial_ascii_text += chr(next_byte)
                            except Exception:
                                raise ProtocolError(next_byte, pending_data)
                            continue
                case State.HMSG_END:
                    match next_byte:
                        case Character.newline:
                            set_state(State.HMSG_PAYLOAD)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.HMSG_PAYLOAD:
                    assert self._partial_msg is not None, "pending_msg is None"
                    pending_data = bytes([next_byte]) + pending_data
                    if len(pending_data) >= self._expected_total_size + CRLF_SIZE:
                        msg = self._partial_msg
                        self._partial_msg = None
                        header = pending_data[: self._expected_header_size]
                        if header[-4:] != b"\r\n\r\n":
                            raise ProtocolError(next_byte, pending_data)
                        msg.header = header[:-4]
                        payload = pending_data[
                            self._expected_header_size : self._expected_total_size
                        ]
                        msg.payload = payload
                        self._data_received = pending_data[
                            self._expected_total_size + CRLF_SIZE :
                        ]
                        self._events_received.append(msg)
                        set_state(State.OP_END)
                        set_state(State.OP_START)
                        continue
                    else:
                        self._data_received = pending_data
                        yield None
                        continue
                case State.OP_M:
                    match next_byte:
                        case Character.S | Character.s:
                            set_state(State.OP_MS)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_MS:
                    match next_byte:
                        case Character.G | Character.g:
                            set_state(State.OP_MSG)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_MSG:
                    match next_byte:
                        case Character.space:
                            set_state(State.OP_MSG_SPC)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_MSG_SPC:
                    match next_byte:
                        case Character.carriage_return:
                            raise ProtocolError(next_byte, pending_data)
                        case Character.newline:
                            raise ProtocolError(next_byte, pending_data)
                        case Character.space:
                            raise ProtocolError(next_byte, pending_data)
                        case _:
                            try:
                                self._partial_ascii_text += chr(next_byte)
                            except Exception:
                                raise ProtocolError(next_byte, pending_data)
                            set_state(State.MSG_ARG)
                            continue
                case State.MSG_ARG:
                    match next_byte:
                        case Character.newline:
                            raise ProtocolError(next_byte, pending_data)
                        case Character.carriage_return:
                            set_state(State.MSG_END)
                            args = self._partial_ascii_text.split(" ")
                            nbargs = len(args)
                            self._partial_ascii_text = ""
                            match nbargs:
                                case 4:
                                    subject, raw_sid, reply_to, raw_total_size = args
                                case 3:
                                    reply_to = ""
                                    subject, raw_sid, raw_total_size = args
                                case _:
                                    raise ProtocolError(next_byte, pending_data)
                            try:
                                sid = int(raw_sid)
                                self._expected_total_size = int(raw_total_size)
                            except Exception as e:
                                raise ProtocolError(next_byte, pending_data) from e
                            self._partial_msg = MsgEvent(
                                Operation.MSG,
                                sid=sid,
                                subject=subject,
                                reply_to=reply_to,
                                payload=b"",
                                header=b"",
                            )
                            continue
                        case _:
                            try:
                                self._partial_ascii_text += chr(next_byte)
                            except Exception:
                                raise ProtocolError(next_byte, pending_data)
                            continue
                case State.MSG_END:
                    match next_byte:
                        case Character.newline:
                            set_state(State.MSG_PAYLOAD)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.MSG_PAYLOAD:
                    assert self._partial_msg is not None, "pending_msg is None"
                    pending_data = bytes([next_byte]) + pending_data
                    if len(pending_data) >= self._expected_total_size + CRLF_SIZE:
                        msg = self._partial_msg
                        self._partial_msg = None
                        msg.payload = pending_data[: self._expected_total_size]
                        self._data_received = pending_data[
                            self._expected_total_size + CRLF_SIZE :
                        ]
                        self._events_received.append(msg)
                        set_state(State.OP_END)
                        set_state(State.OP_START)
                        continue
                    else:
                        self._data_received = pending_data
                        yield None
                        continue
                case State.OP_I:
                    match next_byte:
                        case Character.N | Character.n:
                            set_state(State.OP_IN)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_IN:
                    match next_byte:
                        case Character.F | Character.f:
                            set_state(State.OP_INF)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_INF:
                    match next_byte:
                        case Character.O | Character.o:
                            set_state(State.OP_INFO)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_INFO:
                    match next_byte:
                        case Character.space:
                            set_state(State.OP_INFO_SPC)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_INFO_SPC:
                    match next_byte:
                        case Character.left_json_bracket:
                            set_state(State.INFO_ARG)
                            pending = bytes([next_byte]) + pending_data
                            self._data_received = pending
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.INFO_ARG:
                    pending = bytes([next_byte]) + pending_data
                    if CRLF in pending:
                        end = pending.index(CRLF)
                        data = pending[:end]
                        self._data_received = pending[end + CRLF_SIZE :]
                        set_state(State.OP_END)
                        set_state(State.OP_START)
                        self._events_received.append(parse_info(data))
                        continue
                    else:
                        self._data_received = pending
                        yield None
                        continue
                case State.OP_PLUS:
                    match next_byte:
                        case Character.O | Character.o:
                            set_state(State.OP_PLUS_O)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_PLUS_O:
                    match next_byte:
                        case Character.K | Character.k:
                            set_state(State.OP_PLUS_OK)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_PLUS_OK:
                    match next_byte:
                        case Character.carriage_return:
                            set_state(State.OP_END)
                            self._events_received.append(Event(Operation.OK))
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_MINUS:
                    match next_byte:
                        case Character.E | Character.e:
                            set_state(State.OP_MINUS_E)
                            continue

                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_MINUS_E:
                    match next_byte:
                        case Character.R | Character.r:
                            set_state(State.OP_MINUS_ER)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_MINUS_ER:
                    match next_byte:
                        case Character.R | Character.r:
                            set_state(State.OP_MINUS_ERR)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_MINUS_ERR:
                    match next_byte:
                        case Character.space:
                            set_state(State.OP_MINUS_ERR_SPC)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_MINUS_ERR_SPC:
                    match next_byte:
                        case Character.carriage_return:
                            raise ProtocolError(next_byte, pending_data)
                        case Character.newline:
                            raise ProtocolError(next_byte, pending_data)
                        case _:
                            try:
                                self._partial_ascii_text += chr(next_byte)
                            except Exception:
                                raise ProtocolError(next_byte, pending_data)
                            set_state(State.MINUS_ERR_ARG)
                            continue
                case State.MINUS_ERR_ARG:
                    match next_byte:
                        case Character.carriage_return:
                            msg = self._partial_ascii_text
                            set_state(State.OP_END)
                            self._events_received.append(ErrorEvent(Operation.ERR, msg))
                            self._partial_ascii_text = ""
                        case Character.newline:
                            raise ProtocolError(next_byte, pending_data)
                        case _:
                            try:
                                self._partial_ascii_text += chr(next_byte)
                                continue
                            except Exception:
                                raise ProtocolError(next_byte, pending_data)
                case State.OP_P:
                    match next_byte:
                        case Character.I | Character.i:
                            set_state(State.OP_PI)
                            continue
                        case Character.O | Character.o:
                            set_state(State.OP_PO)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_PI:
                    match next_byte:
                        case Character.N | Character.n:
                            set_state(State.OP_PIN)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_PIN:
                    match next_byte:
                        case Character.G | Character.g:
                            set_state(State.OP_PING)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_PING:
                    match next_byte:
                        case Character.carriage_return:
                            set_state(State.OP_END)
                            self._events_received.append(Event(Operation.PING))
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_PO:
                    match next_byte:
                        case Character.N | Character.n:
                            set_state(State.OP_PON)
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_PON:
                    match next_byte:
                        case Character.G | Character.g:
                            set_state(State.OP_PONG)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_PONG:
                    match next_byte:
                        case Character.carriage_return:
                            set_state(State.OP_END)
                            self._events_received.append(Event(Operation.PONG))
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case State.OP_END:
                    match next_byte:
                        case Character.newline:
                            set_state(State.OP_START)
                            continue
                        case _:
                            raise ProtocolError(next_byte, pending_data)
                case _:
                    raise ProtocolError(next_byte, pending_data)
