"""
NATS protocol parser.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Iterator

from .common import (
    CRLF,
    CRLF_SIZE,
    OK_EVENT,
    PING_EVENT,
    PONG_EVENT,
    ErrorEvent,
    Event,
    HMsgEvent,
    MsgEvent,
    ProtocolError,
    State3102,
    parse_info,
)

STOP_OP = bytearray(CRLF)
STOP_HEADER = bytearray(b"\r\n\r\n")
PING_OP = bytearray(b"PING")
PONG_OP = bytearray(b"PONG")
OK_OP = bytearray(b"+OK\r\n")
PING_OR_PONG_LEN = len(PING_OP)
PING_OR_PONG_OP_LEN = PING_OR_PONG_LEN + CRLF_SIZE


class Parser310:
    """NATS Protocol parser."""

    __slots__ = ["_closed", "_state", "_data_received", "_events_received", "__loop__"]

    def __init__(self) -> None:
        # Initialize the parser state.
        self._closed = False
        self._data_received = bytearray()
        self._events_received: list[Event] = []
        # Initialize the parser iterator
        self.__loop__ = self.__parse__()

    def events_received(self) -> list[Event]:
        """Pop and return the events generated by the parser."""
        events = self._events_received
        self._events_received = []
        return events

    def parse(self, data: bytes | bytearray) -> None:
        self._data_received.extend(data)
        self.__loop__.__next__()

    def __parse__(self) -> Iterator[None]:
        """Parse some bytes."""

        expected_header_size = 0
        expected_total_size = 0
        partial_msg: MsgEvent | HMsgEvent | None = None
        state = State3102.AWAITING_CONTROL_LINE

        while not self._closed:
            # If there is no data to parse, yield None.
            if not self._data_received:
                yield None
                continue

            # Take the first byte
            next_byte = self._data_received[0]

            match state:
                case State3102.AWAITING_CONTROL_LINE:
                    match next_byte:
                        # case "M": Fast path for MSG
                        case 77:
                            try:
                                end = self._data_received.index(CRLF)
                            except ValueError:
                                yield None
                                continue

                            data = self._data_received[4:end]
                            args = data.split(b" ")
                            match len(args):
                                case 4:
                                    subject, raw_sid, reply_to, raw_total_size = args
                                case 3:
                                    reply_to = b""
                                    subject, raw_sid, raw_total_size = args
                                case _:
                                    raise ProtocolError(next_byte, self._data_received)
                            try:
                                sid = int(raw_sid)
                                expected_total_size = int(raw_total_size)
                            except Exception as e:
                                raise ProtocolError(
                                    next_byte, self._data_received
                                ) from e
                            if (
                                len(self._data_received[end + 2 :])
                                >= expected_total_size + CRLF_SIZE
                            ):
                                self._events_received.append(
                                    MsgEvent(
                                        sid=sid,
                                        subject=subject.decode(),
                                        reply_to=reply_to.decode(),
                                        payload=self._data_received[
                                            end + 2 : end + 2 + expected_total_size
                                        ],
                                    )
                                )
                                self._data_received = self._data_received[
                                    end + expected_total_size + 7 :
                                ]
                                continue
                            else:
                                partial_msg = MsgEvent(
                                    sid=sid,
                                    subject=subject.decode(),
                                    reply_to=reply_to.decode(),
                                    payload=bytearray(),
                                )
                                state = State3102.AWAITING_MSG_PAYLOAD
                                self._data_received: bytearray = self._data_received[
                                    end + 2 :
                                ]
                                yield None
                                continue
                        # case "H": Fast path for HMSG
                        case 72:
                            try:
                                end = self._data_received.index(CRLF)
                            except ValueError:
                                yield None
                                continue
                            args = self._data_received[5:end].split(b" ")
                            match len(args):
                                case 5:
                                    (
                                        subject,
                                        raw_sid,
                                        reply_to,
                                        raw_header_size,
                                        raw_total_size,
                                    ) = args
                                case 4:
                                    reply_to = b""
                                    (
                                        subject,
                                        raw_sid,
                                        raw_header_size,
                                        raw_total_size,
                                    ) = args
                                case _:
                                    raise ProtocolError(next_byte, self._data_received)
                            try:
                                expected_header_size = int(raw_header_size)
                                expected_total_size = int(raw_total_size)
                                sid = int(raw_sid)
                            except Exception as e:
                                raise ProtocolError(
                                    next_byte, self._data_received
                                ) from e
                            if (
                                len(self._data_received[end + 2 :])
                                >= expected_total_size + CRLF_SIZE
                            ):
                                if (
                                    self._data_received[
                                        end + expected_header_size - 2 : end
                                        + 2
                                        + expected_header_size
                                    ]
                                    != STOP_HEADER
                                ):
                                    raise ProtocolError(
                                        next_byte,
                                        self._data_received[
                                            end + 2 : end + 2 + expected_header_size
                                        ],
                                    )
                                self._events_received.append(
                                    HMsgEvent(
                                        sid=sid,
                                        subject=subject.decode(),
                                        reply_to=reply_to.decode(),
                                        payload=self._data_received[
                                            end + 2 + expected_header_size : end
                                            + 2
                                            + expected_total_size
                                        ],
                                        header=self._data_received[
                                            end + 2 : end - 2 + expected_header_size
                                        ],
                                    )
                                )
                                self._data_received = self._data_received[
                                    end + expected_total_size + 7 :
                                ]
                                continue
                            else:
                                partial_msg = HMsgEvent(
                                    sid=sid,
                                    subject=subject.decode(),
                                    reply_to=reply_to.decode(),
                                    payload=bytearray(),
                                    header=bytearray(),
                                )
                                state = State3102.AWAITING_HMSG_PAYLOAD
                                self._data_received = self._data_received[end + 2 :]
                                yield None
                                continue
                        # case "P": Fast path for PING and PONG
                        case 80:
                            if len(self._data_received) >= PING_OR_PONG_OP_LEN:
                                if (
                                    self._data_received[4:PING_OR_PONG_OP_LEN]
                                    != STOP_OP
                                ):
                                    raise ProtocolError(next_byte, self._data_received)
                                if self._data_received[:PING_OR_PONG_LEN] == PING_OP:
                                    self._events_received.append(PING_EVENT)
                                elif self._data_received[:PING_OR_PONG_LEN] == PONG_OP:
                                    self._events_received.append(PONG_EVENT)
                                else:
                                    raise ProtocolError(next_byte, self._data_received)
                                self._data_received = self._data_received[
                                    PING_OR_PONG_OP_LEN:
                                ]
                                continue
                            # Split buffer
                            else:
                                yield None
                                continue
                        # case "I": Fast path for INFO
                        case 73:
                            try:
                                end = self._data_received.index(CRLF)
                            except ValueError:
                                yield None
                                continue
                            try:
                                self._events_received.append(
                                    parse_info(self._data_received[5:end])
                                )
                            except Exception as e:
                                raise ProtocolError(
                                    next_byte, self._data_received[5:end]
                                ) from e
                            self._data_received = self._data_received[end + 3 :]
                            continue
                        # case "+": Fast path for +OK
                        case 43:
                            if len(self._data_received) >= 5:
                                if self._data_received[:5] != OK_OP:
                                    raise ProtocolError(
                                        next_byte, self._data_received[:5]
                                    )
                                self._events_received.append(OK_EVENT)
                                self._data_received = self._data_received[5:]
                                continue
                            else:
                                yield None
                                continue
                        # case "-": Fast path for -ERR
                        case 45:
                            try:
                                end = self._data_received.index(CRLF)
                            except ValueError:
                                yield None
                                continue
                            msg = self._data_received[5:end].decode()
                            if msg[0] != "'":
                                raise ProtocolError(next_byte, self._data_received)
                            if msg[-1] != "'":
                                raise ProtocolError(next_byte, self._data_received)
                            self._events_received.append(ErrorEvent(msg[1:-1].lower()))
                            self._data_received = self._data_received[end + CRLF_SIZE :]
                            continue
                        # Anything else is an error
                        case _:
                            raise ProtocolError(next_byte, self._data_received)
                # We're waiting for some HMSG header and payload
                case State3102.AWAITING_HMSG_PAYLOAD:
                    assert partial_msg is not None, "pending_msg is None"
                    if len(self._data_received) >= expected_total_size + CRLF_SIZE:
                        if (
                            self._data_received[
                                expected_header_size - 4 : expected_header_size
                            ]
                            != STOP_HEADER
                        ):
                            raise ProtocolError(
                                next_byte, self._data_received[:expected_header_size]
                            )
                        partial_msg.header = self._data_received[
                            : expected_header_size - 4
                        ]
                        partial_msg.payload = self._data_received[
                            expected_header_size:expected_total_size
                        ]
                        self._data_received = self._data_received[
                            expected_total_size + CRLF_SIZE + 1 :
                        ]
                        self._events_received.append(partial_msg)
                        state = State3102.AWAITING_CONTROL_LINE
                        continue
                    else:
                        yield None
                        continue
                # We're waiting for some MSG payload
                case State3102.AWAITING_MSG_PAYLOAD:
                    assert partial_msg is not None, "pending_msg is None"
                    if len(self._data_received) >= expected_total_size + CRLF_SIZE:
                        partial_msg.payload = self._data_received[:expected_total_size]
                        self._data_received = self._data_received[
                            expected_total_size + CRLF_SIZE + 1 :
                        ]
                        self._events_received.append(partial_msg)
                        state = State3102.AWAITING_CONTROL_LINE
                        continue
                    else:
                        yield None
                        continue


if TYPE_CHECKING:
    from .common import Parser as ParserProtocol

    # Verify that Parser implements ParserProtocol
    parser: ParserProtocol = Parser310()
